## bomblab

### 1. phase_1

使用命令

```
gdb bomb //调试bomb程序
```

使用命令

```
disas phase_1   //将函数phase_1反汇编
```

得到的反汇编代码为

```
1   0x0000000000400ee0 <+0>:     sub    $0x8,%rsp
2   0x0000000000400ee4 <+4>:     mov    $0x402400,%esi
3   0x0000000000400ee9 <+9>:     callq  0x401338 <strings_not_equal>
4   0x0000000000400eee <+14>:    test   %eax,%eax
5   0x0000000000400ef0 <+16>:    je     0x400ef7 <phase_1+23>
6   0x0000000000400ef2 <+18>:    callq  0x40143a <explode_bomb>
7   0x0000000000400ef7 <+23>:    add    $0x8,%rsp
8   0x0000000000400efb <+27>:    retq   
```

我们来分析一下这个反汇编代码。



第二行将地址为0x402400的值传入%esi，然后第三行调用strings_not_equal函数

第四行用来检测%eax里的值是否为0(%eax用来装函数返回值)，也就是检查strings_not_equal的返回值是否为0

第五行是若返回0(两个字符串相等)，则跳转到phase_1函数的起始地址+23的位置上(也就是第七行)

第六行则是如果不跳转(两个字符串不相等)，则炸弹爆炸



理清楚这个汇编代码的意思，再执行

```
x /s 0x402400 			//将地址0x402400的值用字符串形式打出
```

最后可以得到phase_1的密码 ： "Border relations with Canada have never been better."



### 2. phase_2



phase_2的反汇编如下:

```
     0x0000000000400efe <+2>:     sub    $0x28,%rsp
     0x0000000000400f02 <+6>:     mov    %rsp,%rsi
     0x0000000000400f05 <+9>:     callq  0x40145c <read_six_numbers>
     0x0000000000400f0a <+14>:    cmpl   $0x1,(%rsp)
     0x0000000000400f0e <+18>:    je     0x400f30 <phase_2+52>
     0x0000000000400f10 <+20>:    callq  0x40143a <explode_bomb>
     0x0000000000400f15 <+25>:    jmp    0x400f30 <phase_2+52>
     0x0000000000400f17 <+27>:    mov    -0x4(%rbx),%eax
     0x0000000000400f1a <+30>:    add    %eax,%eax
     0x0000000000400f1c <+32>:    cmp    %eax,(%rbx)
     0x0000000000400f1e <+34>:    je     0x400f25 <phase_2+41>
     0x0000000000400f20 <+36>:    callq  0x40143a <explode_bomb>
     0x0000000000400f25 <+41>:    add    $0x4,%rbx
     0x0000000000400f29 <+45>:    cmp    %rbp,%rbx
     0x0000000000400f2c <+48>:    jne    0x400f17 <phase_2+27>
     0x0000000000400f2e <+50>:    jmp    0x400f3c <phase_2+64>
     0x0000000000400f30 <+52>:    lea    0x4(%rsp),%rbx
     0x0000000000400f35 <+57>:    lea    0x18(%rsp),%rbp
     0x0000000000400f3a <+62>:    jmp    0x400f17 <phase_2+27>
     0x0000000000400f3c <+64>:    add    $0x28,%rsp
```

+9处: 函数read_six_numbers读了六个数字

+14处:比较栈顶地址在内存中的值和1的大小，可以得知第一个数=1

跳到52处，将rsp+4(第二个数的地址)放到rbx(此时rbx存放的是第二个数的地址)中，经过+62处的指令跳到27处



+27处: 将rbx-4(第一个数的地址)在内存中的值放到%eax

+30处:eax变成2

+32处:比较eax的值和rbx在内存中的值(第二个数的值)，所以第二个数=2

跳到41处，将rbx+4（此时rbx存放的是第三个数的地址），然后因为%rbp在+57处存了一个很奇怪的值，jne成立(比较指令结果不等)，跳到+27



+27处再将rbx-4(第二个数的地址)在内存中的值放到%eax中继续重复执行之前的操作......



所以我们可以发现这是一个循环，每次都是当前的数等于上次的那个数*2(因为+30处的%eax+%eax)



**所以最后的结果是1 2 4 8 16 32**



